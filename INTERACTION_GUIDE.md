# Markdown 文档批注组件 - 交互逻辑详解

## 📋 概述

`markdown-annotation-kit` 是一个功能完整的 React 组件库，用于在 Markdown 文档中添加批注功能。它支持文本选择、批注创建、标签回显和双向锚定等核心功能。

## 🎯 核心功能

### 1. 文本选择与批注创建

#### 交互流程

1. **文本选择**
   - 用户在 Markdown 渲染区域中任意选择文本
   - 支持鼠标拖拽、键盘选择等多种选择方式
   - 选择完成后，系统自动捕获选区信息

2. **浮窗显示**
   - 选择文本后，在选区上方自动弹出交互浮窗
   - 浮窗位置智能调整：
     - 优先显示在选区上方
     - 如果上方空间不足，自动切换到下方
     - 水平方向居中显示，并确保不超出视口边界

3. **批注输入**
   - 浮窗中包含：
     - 选中的文本预览（最多显示 96 个字符）
     - 批注内容输入框（多行文本）
     - "取消" 和 "确认" 按钮
   - 支持键盘操作：
     - `ESC` 键关闭浮窗
     - 输入框自动获得焦点

4. **批注确认**
   - 点击 "确认" 按钮后：
     - 系统自动生成批注 ID（从现有最大 ID + 1）
     - 在源数据中插入 `<mark_N></mark_N>` 标签包裹选中文本
     - 原文中被标记的文本以下划线形式高亮显示
     - 批注卡片出现在侧边栏
     - 浮窗自动关闭

#### 示例

**初始 Markdown：**
```markdown
# 文档标题

这是一段可以批注的文本内容。
```

**用户选择 "可以批注的文本" 并输入批注 "这段内容需要进一步说明"**

**确认后的 Markdown：**
```markdown
# 文档标题

这是一段<mark_1>可以批注的文本</mark_1>内容。
```

**视觉效果：**
- 原文中 "可以批注的文本" 以下划线高亮显示
- 侧边栏出现批注卡片，显示批注内容

---

### 2. 标签系统与数据持久化

#### 标签格式

- **标签格式**：`<mark_N></mark_N>`
  - `N` 为批注 ID（正整数，从 1 开始）
  - 标签必须成对出现
  - ID 必须唯一

#### 标签插入规则

1. **位置计算**
   - 系统维护一个 `boundaryMap`，映射清理后的文本索引到原始索引
   - 根据用户选择的文本位置（基于清理后的 Markdown），精确计算在原始数据中的插入位置

2. **ID 生成**
   - 自动递增：新批注 ID = 现有最大 ID + 1
   - 确保 ID 唯一性

3. **标签嵌套处理**
   - 支持多个批注标签
   - 标签可以相邻，但不能嵌套

#### 示例

**多个批注：**
```markdown
这是<mark_1>第一段</mark_1>批注，这是<mark_2>第二段</mark_2>批注。
```

**相邻批注：**
```markdown
这是<mark_1>第一段</mark_1><mark_2>第二段</mark_2>批注。
```

---

### 3. 标签回显功能

#### 工作原理

1. **数据解析**
   - 组件接收包含 `<mark_N>` 标签的 Markdown 数据
   - `stripMarkTags` 函数解析标签：
     - 提取所有 `<mark_N></mark_N>` 标签
     - 记录每个标签的 ID 和位置范围
     - 生成清理后的 Markdown（去除标签）
     - 生成边界映射表（用于后续插入新标签）

2. **批注匹配**
   - 组件接收批注数据数组 `annotations`
   - 每个批注项包含 `id` 和 `note`
   - 系统根据标签中的 ID 匹配对应的批注内容

3. **视觉回显**
   - 原文中被标签包裹的文本自动以下划线高亮显示
   - 侧边栏自动显示对应的批注卡片

#### 示例

**带标签的源数据：**
```markdown
# 示例文档

<mark_1>这段文本已经被标记了</mark_1>，可以自动回显。

<mark_2>另一段标记的文本</mark_2>。
```

**批注数据：**
```json
[
  { "id": 1, "note": "这是第一个批注" },
  { "id": 2, "note": "这是第二个批注" }
]
```

**效果：**
- "这段文本已经被标记了" 以下划线高亮，侧边栏显示批注 #1
- "另一段标记的文本" 以下划线高亮，侧边栏显示批注 #2

---

### 4. 双向锚定功能

#### 功能说明

双向锚定允许用户在批注卡片和原文高亮之间快速跳转：

1. **从原文到批注卡片**
   - 点击原文中的高亮文本
   - 系统自动滚动到对应的批注卡片
   - 批注卡片高亮显示（闪烁动画）
   - 原文高亮也同步闪烁

2. **从批注卡片到原文**
   - 点击侧边栏中的批注卡片
   - 系统自动滚动到原文中的对应位置
   - 如果原文不在视野内，平滑滚动到视野中心
   - 原文高亮闪烁提示
   - 批注卡片也同步闪烁

3. **智能滚动**
   - 检查目标元素是否在视野内
   - 如果不在视野内，使用 `scrollIntoView` 滚动
   - 使用平滑滚动动画（`behavior: "smooth"`）

#### 示例场景

**场景 1：长文档浏览**
```
用户正在查看一篇很长的文档，看到第 50 行的批注卡片。
点击卡片后，页面自动滚动到第 200 行的对应原文位置。
```

**场景 2：快速定位**
```
用户在阅读原文时，看到高亮的文本。
点击高亮文本，侧边栏自动滚动到对应的批注卡片。
```

---

### 5. 批注标记 Flag

#### 功能说明

在有批注的文本段旁边显示标记 flag，显示该段内的批注数量。

1. **Flag 显示**
   - 圆形徽章，显示批注数量
   - 位置：文本段右侧
   - 样式：小圆形，带边框和背景色

2. **批注列表**
   - 点击 flag 后显示该段的所有批注列表
   - 列表以弹窗形式显示
   - 显示每个批注的 ID、内容和摘录

3. **快速定位**
   - 点击列表中的批注项，自动定位到原文并高亮

#### 示例

**同一段文本有多个批注：**
```markdown
这是<mark_1>第一段</mark_1>批注，<mark_2>第二段</mark_2>也在同一行。
```

**效果：**
- 该行文本右侧显示 flag，显示数字 "2"
- 点击 flag 后，弹出列表显示两个批注
- 点击列表中的任意批注，定位到对应的原文位置

---

## 📝 典型使用场景示例

### 示例 1：文档评审

**场景描述：**
团队协作评审技术文档，需要添加修改建议。

**初始文档：**
```markdown
# API 设计文档

## 用户认证

用户登录接口需要提供用户名和密码。
```

**操作流程：**
1. 选择 "用户名和密码"
2. 输入批注："建议使用 OAuth 2.0 认证"
3. 确认后，文档变为：
   ```markdown
   # API 设计文档
   
   ## 用户认证
   
   用户登录接口需要提供<mark_1>用户名和密码</mark_1>。
   ```
4. 侧边栏显示批注卡片
5. 其他成员可以点击批注查看建议

---

### 示例 2：学习笔记

**场景描述：**
在学习 Markdown 语法时，对重点内容添加批注。

**初始文档：**
```markdown
# Markdown 语法

## 强调

**粗体文本** 使用两个星号包裹。
*斜体文本* 使用一个星号包裹。
```

**操作流程：**
1. 选择 "两个星号包裹"
2. 输入批注："也可以使用两个下划线 __粗体__"
3. 选择 "一个星号包裹"
4. 输入批注："也可以使用一个下划线 _斜体_"
5. 最终文档：
   ```markdown
   # Markdown 语法
   
   ## 强调
   
   **粗体文本** 使用<mark_1>两个星号包裹</mark_1>。
   *斜体文本* 使用<mark_2>一个星号包裹</mark_2>。
   ```

---

### 示例 3：代码审查

**场景描述：**
代码审查时，对文档中的设计说明添加疑问和建议。

**初始文档：**
```markdown
# 系统架构设计

## 数据库设计

系统使用 MySQL 作为主数据库，Redis 作为缓存层。
```

**操作流程：**
1. 选择 "MySQL"
2. 输入批注："考虑使用 PostgreSQL，支持更好的 JSON 查询"
3. 选择 "Redis"
4. 输入批注："建议评估 Memcached 的性能"
5. 最终文档：
   ```markdown
   # 系统架构设计
   
   ## 数据库设计
   
   系统使用<mark_1>MySQL</mark_1>作为主数据库，<mark_2>Redis</mark_2>作为缓存层。
   ```

---

### 示例 4：从服务器加载已保存的批注

**场景描述：**
从服务器加载包含批注标签的文档，自动回显批注。

**服务器返回的数据：**
```markdown
# 项目计划

## 第一阶段

<mark_1>需求分析</mark_1>需要 2 周时间。
<mark_2>原型设计</mark_2>需要 1 周时间。
```

**批注数据：**
```json
[
  { "id": 1, "note": "需要与产品经理确认详细需求" },
  { "id": 2, "note": "使用 Figma 进行设计" }
]
```

**组件使用：**
```tsx
<MarkdownAnnotator
  defaultValue={markdownFromServer}
  defaultAnnotations={annotationsFromServer}
/>
```

**效果：**
- "需求分析" 和 "原型设计" 自动高亮显示
- 侧边栏自动显示对应的批注卡片
- 用户可以继续添加新批注

---

### 示例 5：受控模式 - 实时同步到服务器

**场景描述：**
需要将批注实时保存到服务器。

**组件使用：**
```tsx
const [markdown, setMarkdown] = useState(initialMarkdown);
const [annotations, setAnnotations] = useState([]);

const handleMarkdownChange = async (newMarkdown) => {
  setMarkdown(newMarkdown);
  await saveToServer({ markdown: newMarkdown });
};

const handleAnnotationsChange = async (newAnnotations) => {
  setAnnotations(newAnnotations);
  await saveToServer({ annotations: newAnnotations });
};

<MarkdownAnnotator
  value={markdown}
  onChange={handleMarkdownChange}
  annotations={annotations}
  onAnnotationsChange={handleAnnotationsChange}
/>
```

**工作流程：**
1. 用户创建批注
2. `onChange` 和 `onAnnotationsChange` 立即触发
3. 数据自动保存到服务器
4. 支持撤销/重做功能（通过状态管理实现）

---

## 🔄 完整交互流程图

```
┌─────────────────────────────────────────────────────────┐
│                   用户选择文本                          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│           浮窗弹出（显示选中文本预览）                    │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│           用户输入批注内容                              │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│           点击"确认"按钮                                │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│   1. 生成批注 ID (N)                                    │
│   2. 插入 <mark_N></mark_N> 标签                        │
│   3. 原文高亮显示（下划线）                             │
│   4. 侧边栏显示批注卡片                                 │
└─────────────────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│           双向锚定功能可用                              │
│   • 点击高亮文本 → 定位到批注卡片                       │
│   • 点击批注卡片 → 定位到原文                           │
└─────────────────────────────────────────────────────────┘
```

---

## 🎨 UI/UX 特性

### 视觉反馈

1. **高亮样式**
   - 下划线装饰（`decoration-ink-400`）
   - 背景色：淡黄色（`bg-yellow-100/70`）
   - 激活状态：更深的黄色（`bg-yellow-200`）
   - 悬停效果：背景色加深

2. **闪烁动画**
   - 点击锚定时，目标元素闪烁 1.6 秒
   - 使用 CSS 动画实现平滑效果

3. **Flag 标记**
   - 圆形徽章，显示批注数量
   - 悬停时背景色变化
   - 激活时显示边框高亮

### 键盘支持

1. **浮窗操作**
   - `ESC` 键关闭浮窗
   - `Tab` 键在按钮间切换焦点

2. **批注导航**
   - 高亮文本支持 `Enter` 和 `Space` 键激活
   - 批注卡片支持 `Enter` 和 `Space` 键激活

3. **无障碍访问**
   - 所有交互元素都有 `aria-label`
   - 支持键盘导航
   - 符合 WCAG 标准

---

## 📊 数据流

### 状态管理

```
┌──────────────┐
│  rawMarkdown │  (包含 <mark_N> 标签的原始数据)
└──────┬───────┘
       │
       ▼ stripMarkTags()
┌──────────────┐
│cleanMarkdown │  (清理后的 Markdown)
│boundaryMap   │  (索引映射表)
│annotations   │  (从标签提取的批注范围)
└──────┬───────┘
       │
       ▼ ReactMarkdown 渲染
┌──────────────┐
│  渲染的 DOM  │  (带 data-clean-start/end 属性)
└──────┬───────┘
       │
       ▼ 用户选择文本
┌──────────────┐
│selectionState│  (选择状态：start, end, text, rect)
└──────┬───────┘
       │
       ▼ 用户确认批注
┌──────────────┐
│injectMarkTags│  (使用 boundaryMap 插入标签)
└──────┬───────┘
       │
       ▼
┌──────────────┐
│  rawMarkdown │  (更新后的数据，包含新标签)
└──────────────┘
```

---

## 🛠️ 技术实现要点

### 1. 位置计算

- 使用 `boundaryMap` 映射清理后的索引到原始索引
- 通过 `data-clean-start` 和 `data-clean-end` 属性追踪文本位置
- 使用 `resolveOffset` 函数计算精确的选择位置

### 2. 标签解析

- 正则表达式匹配 `<mark_N>` 和 `</mark_N>` 标签
- 使用栈结构处理嵌套和重叠的标签
- 生成完整的批注范围信息

### 3. 双向锚定

- 使用 `ref` 管理高亮元素和卡片元素的引用
- `scrollIntoView` API 实现平滑滚动
- `getBoundingClientRect` 检查元素是否在视野内

### 4. Flag 标记

- 动态计算文本段的位置
- 使用 `Map` 管理多个 flag 的位置
- Portal 渲染弹窗，避免 z-index 问题

---

## 📚 最佳实践

### 1. 数据持久化

```tsx
// 推荐：使用受控模式
const [markdown, setMarkdown] = useState(initialMarkdown);
const [annotations, setAnnotations] = useState([]);

<MarkdownAnnotator
  value={markdown}
  onChange={(newMarkdown) => {
    setMarkdown(newMarkdown);
    saveToServer(newMarkdown);
  }}
  annotations={annotations}
  onAnnotationsChange={(newAnnotations) => {
    setAnnotations(newAnnotations);
    saveToServer(newAnnotations);
  }}
/>
```

### 2. 错误处理

```tsx
// 处理标签格式错误
try {
  const result = stripMarkTags(markdown);
  // 使用 result
} catch (error) {
  console.error('标签解析失败:', error);
  // 降级处理
}
```

### 3. 性能优化

```tsx
// 使用 useMemo 缓存解析结果
const parseResult = useMemo(() => stripMarkTags(markdown), [markdown]);

// 使用 useCallback 缓存事件处理函数
const handleAnnotationFocus = useCallback((id) => {
  // 处理逻辑
}, []);
```

---

## 🎯 总结

`markdown-annotation-kit` 提供了一个完整的文档批注解决方案，支持：

✅ **文本选择与批注创建** - 直观的交互方式  
✅ **标签系统** - 标准化的数据格式  
✅ **标签回显** - 无缝的数据恢复  
✅ **双向锚定** - 高效的导航体验  
✅ **Flag 标记** - 便捷的批注管理  

适用于文档评审、学习笔记、代码审查、协作编辑等多种场景。

